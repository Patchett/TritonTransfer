// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "./gen-cpp/TritonTransfer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include "../utils/utils.hpp"
#include <unordered_map>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using std::rotate;
using boost::shared_ptr;
using namespace  ::no::podcasts::no::learning;
using std::unordered_map;
using std::to_string;

typedef struct ServerAttributes {
    int port;
    string server_name;
    TritonTransferClient *server;
    boost::shared_ptr<TTransport> transport;
} ServerAttributesStruct;

// struct ServerInfo {
//     1: required list<HashValue> server_hash_list,
//     2: required i32 port,
//     3: required ServerAddr server_name,
//     4: required bool file_exists,
// }

class MDServerHandler : virtual public TritonTransferIf {
public:
    vector<ServerAttributesStruct *> *servers;
    MDServerHandler()
    {
        servers = new vector<ServerAttributesStruct *>();
    }

    ~MDServerHandler()
    {
        delete servers;
    }

    void ping()
    {
        // cerr << "ping" << endl;
    }

    void uploadFile(std::vector<ServerInfo> &_return, const std::string &file_name, const std::vector<HashValue> &hash_list)
    {
        // cerr << "Entering uploadFile on MDServer.\n";
        removeDuplicateServers();
        ServerAttributesStruct *curr_block_server;
        vector<ServerInfo> *temp_return = new std::vector<ServerInfo>();
        for (int i = 0; i < servers->size(); i++) {
            curr_block_server = connectToBlockServer(servers->at(i)->server_name, servers->at(i)->port);
            if (NULL == curr_block_server) {
                // cerr << "ERROR: Could not establish connection to " << servers->at(i)->server_name << endl;
                servers->erase(servers->begin() + i);
                i--; // offset erasing an element
                continue;
            }
            // cerr << "Connection established to " << servers->at(i)->server_name << " calling uploadFile on " << file_name << endl;
            // At block server, just push_back the _return with the needed hashes + server info
            curr_block_server->server->uploadFile(_return, file_name, hash_list);
            temp_return->push_back(_return.at(0));
            _return.clear();
            // cerr << file_name << " has " << _return.back().server_hash_list.size() << " blocks on " << servers->at(i)->server_name << endl;
            curr_block_server->transport->close();
        }
        // cerr << "temp_return vector has " << temp_return->size() << " elements " << endl;
        for (int i = 0; i < temp_return->size(); i++) {
            _return.push_back(temp_return->at(i));
        }
        // cerr << "_return has " << _return.size() << " entries and the following servers:\n";
        // cerr << "========================================================" << endl;
        for (int i = 0; i < _return.size(); i++) {
            printServerInfo(_return.at(i));
            // cerr << "========================================================" << endl;
        }
        // cerr << _return.size() << " servers responded to uploadFile.\n";
        rotate(servers->begin(), servers->begin() + 1, servers->end()); // Rotate vector for round robin uploads
        // curr_block_server->transport->close();
    }

    void downloadFile(std::vector<ServerInfo> &_return, const std::string &file_name)
    {
        // cerr << "Entering downloadFile on MDServer.\n";
        removeDuplicateServers();
        ServerAttributesStruct *curr_block_server;
        for (int i = 0; i < servers->size(); i++) {
            curr_block_server = connectToBlockServer(servers->at(i)->server_name, servers->at(i)->port);
            if (NULL == curr_block_server) {
                // cerr << "ERROR: Could not establish connection to " << servers->at(i)->server_name << endl;
                servers->erase(servers->begin() + i);
                i--; // offset erasing an element
                continue;
            }
            // cerr << "Connection established to " << servers->at(i)->server_name << " executing calling uploadFile on " << file_name << endl;
            // At block server, just push_back the _return with the hashes for the file + server info
            curr_block_server->server->downloadFile(_return, file_name);
            // cerr << file_name << " has " << _return.back().server_hash_list.size() << " blocks " << " on " << servers->at(i)->server_name << endl;
            curr_block_server->transport->close();
        }
    }

    void bootstrapBlockServer(const int32_t port, const ServerAddr &server_addr)
    {
        ServerAttributesStruct *server_attribs = new ServerAttributesStruct();
        server_attribs->port = port;
        server_attribs->server_name = server_addr;
        servers->push_back(server_attribs);
        // cerr << "Successfully bootstrapped block server with name " << server_attribs->server_name << " on port " << port << endl;
        return;
    }

    ServerAttributesStruct *connectToBlockServer(ServerAddr server_name, int32_t server_port)
    {
        try {
            // cerr << "Attempting to connect to " << server_name << " on port " << server_port << endl;
            boost::shared_ptr<TTransport> socket(new TSocket(server_name, server_port));
            boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
            boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
            TritonTransferClient *tt_block_server = new TritonTransferClient(protocol);
            transport->open();
            // cerr << "Transport opened.\n";
            tt_block_server->ping();
            // cerr << "Successfully connected to " << server_name << " on port " << server_port << endl;
            ServerAttributesStruct *server_attribs = new ServerAttributesStruct();
            server_attribs->port = server_port;
            server_attribs->server_name = server_name;
            server_attribs->server = tt_block_server;
            server_attribs->transport = transport;
            return server_attribs;
        } catch (...) {
            // cerr << "ERROR: Server did not respond to ping!\n";
            return NULL;
        }
    }

    void removeDuplicateServers()
    {
        unordered_map<string, string> *server_ids = new unordered_map<string, string>();
        for (int i = 0; i < servers->size(); i++) {
            string curr_server_id = servers->at(i)->server_name + to_string(servers->at(i)->port);
            if (server_ids->find(curr_server_id) != server_ids->end()) {
                // cerr << "Removing " << curr_server_id << " from servers list\n";
                servers->erase(servers->begin() + i);
                i--; // offset erasing an element
            } else {
                server_ids->insert(std::make_pair(curr_server_id, curr_server_id));
            }
        }
        delete server_ids;
    }

    void downloadBlock(ErrorOrBlock &_return, const HashValue &hv)
    {
        // Not needed
    }

    void uploadBlock(std::string &_return, const HashValue &hv, const Block &block)
    {
        // Not needed
    }

    void printServerInfo(ServerInfo si)
    {
        // cerr << "server_name: " << si.server_name << endl;
        // cerr << "server_ port: " << si.port << endl;
        // cerr << "file_exists: " << si.file_exists << endl;
        // cerr << "size of server_hash_list: " << si.server_hash_list.size() << endl;
    }

};

// TODO get rid of debug stmts

// DONE
// TODO Check that servers are rotating by running with 3 block servers
// TODO try/catch all rpc calls
